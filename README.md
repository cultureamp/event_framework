# EventFramework

EventFramework is the imaginatively-titled event-sourcing framework, developed
by the Murmur team. The API has been designed to make the happy-path simple, and
the complex-path uncomplicated.

## Domain Objects

In order to reduce the risk of naming collisions with existing murmur code, domain
objects should be implemented in a module, under `Domains`, named after the
primary Aggregate:

```ruby
module Domains
  module Person
    class ChangeEmailAddressCommand < EventFramework::Command
    end

    class ChangeEmailAddressCommandHandler < EventFramework::CommandHandler
    end

    class PersonAggregate < EventFramework::Aggregate
    end
  end
end
```

As you can see from the example above, `EventFramework` provides three base
classes that can be used to build domain objects.

### Command

`Command` is a means of descibing and encapsulating the data required when
executing a command against an aggregate.

```ruby
class ChangeEmailAddressCommand < EventFramework::Command
  attribute :person_id, Types::UUID
  attribute :email_address, Types::Strict::String
end
```

`Command` is implemented as a `dry-struct` (http://dry-rb.org/gems/dry-struct/),
enabling us to concicely and safely build self-documenting data objects.

### CommandHandler

A `CommandHandler` is the bridge between a Rails Controller actio and the
aggregate it targets. It negotiates the process of instantiating an aggregate and
re-building its internal state from the events in the event store:

```ruby
class ChangeEmailAddressCommandHandler < EventFramework::CommandHandler
  def handle(aggregate_id:, command:)
    metadata.causation_id = "d1bee3f5-0ce6-4483-bd54-8f007260ee19"

    with_aggregate(Person, aggregate_id) do |survey|
      person.change_email_address(command: command, metadata: metadata)
    end
  end
end
```

Instances of `CommandHandler` also provides a `metadata` object, which can be
used to capture request-level data for persistence into the event store.

### Aggregate

All aggregates inherit from the `Aggregate` base class. Building internal state
is handled by a collection of event handlers, defined on the class using the
`apply` helper method:

```ruby
class PersonAggregate < EventFramework::Aggregate
  apply :EmailAddressChanged do |event|
    @email_address = event.email_address
  end
end
```

Commands are implemented as standard methods on the aggregate class. Persisting
the event to the event store is handled by calling `sink_event`.

```ruby
class PersonAggregate < EventFramework::Aggregate
  def change_email_address(command:, metadata:)
    raise InvalidEmailAddressError unless EmailAddress.new(command.email_address).valid?

    sink_event Events::EmailAddressChanged.new(email_address: command.email_address), metadata
  end
end
```

If you are implementing a command that will generate multiple events witin that
command, each event can be staged by calling `stage_event`, and then persisted
by calling `sink_staged_events`

```ruby
class PersonAggregate < EventFramework::Aggregate
  # In this example, assume `command.custom_attributes` is a Hash that looks like:
  #
  # {
  #   disposition: 'focused',
  #   alignment: 'neutral',
  #   origin: 'earth',
  # }
  #
  def add_custom_attributes(command:, metadata:)
    command.custom_attributes.each do |attribute, value|
      stage_event Events::CustomAttributeAdded.new(attribute_name: attribute, value: value), metadata
    end

    sink_staged_events
  end
end
```

## Domain Events

In the example above, you would have noticed `Events::EmailAddressChanged` being
instantited in commands. We refer to them as Domain Events.

Every domain event that can be generated by our platform is described by a single
Ruby class (inheriting from `DomainEvent`) that belongs to the `Events` module:

```ruby
module Events
  class EmailAddressChangedForPerson < EventFramework::DomainEvent
    attribute :new_email_address, Types::Strict::String
  end
end
```

As with `Command`, `DomainEvent` uses `dry-struct` under the hood.

### Internal Persistence

When domain events (and associated metadata) are sunk into the event store, they
are persisted into a PostgreSQL database.

When sourced from the event store, they are encapsulated in a generic `Event`
object. `Event` also contains metadata and additional details from the database:

Attribute            | Description
---------------------|----------------------------------------------------------
`id`                 | The primary key of the event; UUIDv4, automatically generated by the database
`sequence`           | The position of this event in the entire event stream; Automatically generated by the database
`aggregate_id`       | The ID of the aggregate that this event pertains to
`aggregate_sequence` | The position of this event within the aggregate-specific event stream. Integer, generated within the aggregate.
`domain_event`       | An instance of the `DomainEvent` class, populated with the contents of the event body.
`metadata`           | A Struct that contains the following pieces of metadata:

#### Event Metadata
Attribute            | Description
---------------------|----------------------------------------------------------
`user_id`            | The ID of the User who performed the action. Currently taken from Mumur's authn system.
`correlation_id`     | The correlation ID of the event; Usually generated as a unique request ID in the client, and passed via the HTTP request
`causation_id`       | The ID of the Event that caused _this_ Event to be created via a Reactor.
`created_at`         | The time and date (in UTC) that event saved to the database; Automatically generated by the database.



