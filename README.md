# EventFramework

## Core Concepts

The `Aggregate` is a base class for your domain models. It's responsible for
building it's current state from a list of events that are retrieved from the
`EventStore::Source` via the `Repository`.

You can inherit from this class and use the defined API to apply events.

``` ruby
class SurveyAggregate < EventFramework::Aggregate
  # An example of applying the SurveyCreated domain event to an instance of a
  # Survey aggregate.
  apply SurveyCreated do |domain_event|
    @created = true
  end

  # An example of a command that can be run against an aggregate.
  def create(name:)
    add SurveyCreated.new(name: name)
  end
end
```

The `Command` is a base class for the objects that represent actions that
happen to your aggregates.

``` ruby
class SurveyCreateCommand < EventFramework::Command
  attribute :name, EventFramework::Types::Strict::String
end
```

The `CommandHandler` is a base class for handling commands. It needs to be
initialized with an `account_id` and a `user_id`.

It's assumed that the `user_id` is an authenticated user who is performing the
action, and the `account_id` is an account that the authenticated user has
access to.

``` ruby
class SurveyCreateCommandHandler < EventFramework::CommandHandler
  def handle(aggregate_id, command)
    # with_aggregate handles loading and saving the aggregate via the
    # Repository.
    with_aggregate(SurveyAggregate, aggregate_id) do |survey|
      survey.create(name: command.name)
    end
  end
end
```

The `Metadata` class at the top level is for adding metadata to events. At the
moment this consists of `account_id`, `user_id`, `correlation_id`, and
`causation_id`.

Events are modelled as follows:

``` ruby
class SurveyCreated < EventFramework::DomainEvent
  attribute :name, EventFramework::Types::Strict::String
end

Event.new(              # A generic event class that holds the Event information
  id: ,                 # UUID of the event, typically generated by the database.
  sequence: ,           # A number that represents the order of the event in the entire event stream, generated by the database.
  aggregate_id: ,       # UUID of the aggregate (E.g. Survey ID)
  aggregate_sequence: , # An internal sequence number used by the Event Store to ensure consistency.
  metadata: Event::Metadata.new(
    account_id: ,       # The ID of the Account.
    user_id: ,          # The ID of the User who performed the action.
    created_at: ,       # The time the Event was saved to the database, generated by the database.
    correlation_id: ,   # The correlation ID of the Event, passed from the web client.
    causation_id: ,     # The ID of the Event that caused the Event to be created via a Reactor.
  )
  domain_event: SurveyCreated.new(
    name: ,             # The name of the Survey, typically this value would come from request params.
  )
)
```

## Event Store

The `EventStore` consists of two parts. A `Sink` and a `Source`.

The `Sink` is responsible for appending `DomainEvent`s to the database.

The `Source` is responsible for reading events. This can be done using an
offset from the using a `sequence` OR by requesting all events for a given
Aggregate ID.
